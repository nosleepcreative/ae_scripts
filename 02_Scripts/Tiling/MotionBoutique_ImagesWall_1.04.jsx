/* Images Wall script Copyright (c) 2011 Motion Boutique*/var FRAME_RATE = 25; // change this according to your preferencesvar FRAME_DURATION = 1 / FRAME_RATE;// This class represents the main class of the scriptfunction ImagesWall(){	// Variable used to keep track of 'this' reference	var imagesWall = this;		// Create an instance of the utils class to use its functions	var utils = new ImagesWallUtils();	// Script infos	this.scriptName = "ImagesWall.jsx";		this.scriptVersion = "1.04";	this.scriptTitle = "Images Wall";	this.scriptCopyright = "Copyright (c) 2011 Motion Boutique";	this.scriptHomepage = "http://www.motionboutique.com";	this.scriptDescription = "This script creates a wall of images from the selected folder (in the project panel). Images are distributed on a grid.\rEvery step_duration frames, a set of pool_size grid cells are fade in/out during fade_duration frames with new images.\rLayers inpoints can be randomly offset by max_temporal_offset frames, and opacity animation can be eased using the ease_opacity option.";	this.scriptAbout = this.scriptName + ", v" + this.scriptVersion + "\r" + this.scriptCopyright + "\r" + this.scriptHomepage + "\r\r" + this.scriptDescription;			this.scriptUsage =	"\u25BA Select a folder of footages (in the project panel) \r" +						"\u25BA Click on Create"; 		// Errors	this.noFolderErr = "Please select a folder item in the project panel.";		// UI strings 	this.aboutBtnName = "?";	this.gridSettingsGrpName = "Wall Settings";	this.widthStName = "Width:";	this.heightStName = "Height:";	this.durationStName = "Duration (frames):";	this.colsStName = "Columns:";	this.rowsStName = "Rows:";	this.animationSettingsGrpName = "Animation Settings";	this.stepDurationStName = "Step Duration (frames):";	this.fadeDurationStName = "Fade Duration (frames):";	this.poolSizeStName = "Pool Size:";	this.maxRandomTemporalOffsetStName = "Max Temporal Offset (frames):";	this.easeOpacityStName = "Ease Opacity:";	this.easeOpacityCbName = "Enable";	this.popupScaleStName = "Popup Scale:";	this.popupScaleCbName = "Enable";	this.fadeZPosStName = "Fade Z Position:";	this.fadeZPosCbName = "Enable";	this.startTimeStName = "Start Time (frames):";	this.progressInfosStName = "Progress Infos";	this.runBtnName = "Create";		// Default values	this.widthVal = 1920;	this.heightVal = 960;	this.durationVal = 250;	this.colsVal = 22;	this.rowsVal = 8;		this.stepDurationVal = 25;	this.fadeDurationVal = 10;	this.poolSizeVal = 5;	this.maxRandomTemporalOffsetVal = 10;	this.easeOpacityVal = 1;	this.popupScaleVal = false;	this.fadeZPosVal = false;	this.startTimeVal = 0;		// look for existing prefs	if (app.settings.haveSetting("ImagesWall", "Width")) this.widthVal = parseInt(app.settings.getSetting("ImagesWall", "Width"));	if (app.settings.haveSetting("ImagesWall", "Height")) this.heightVal = parseInt(app.settings.getSetting("ImagesWall", "Height"));	if (app.settings.haveSetting("ImagesWall", "Duration")) this.durationVal = parseInt(app.settings.getSetting("ImagesWall", "Duration"));	if (app.settings.haveSetting("ImagesWall", "Cols")) this.colsVal = parseInt(app.settings.getSetting("ImagesWall", "Cols"));	if (app.settings.haveSetting("ImagesWall", "Rows")) this.rowsVal = parseInt(app.settings.getSetting("ImagesWall", "Rows"));	if (app.settings.haveSetting("ImagesWall", "StepDuration")) this.stepDurationVal = parseInt(app.settings.getSetting("ImagesWall", "StepDuration"));	if (app.settings.haveSetting("ImagesWall", "FadeDuration")) this.fadeDurationVal = parseInt(app.settings.getSetting("ImagesWall", "FadeDuration"));	if (app.settings.haveSetting("ImagesWall", "PoolSize")) this.poolSizeVal = parseInt(app.settings.getSetting("ImagesWall", "PoolSize"));	if (app.settings.haveSetting("ImagesWall", "MaxRandomTemporalOffset")) this.maxRandomTemporalOffsetVal = parseInt(app.settings.getSetting("ImagesWall", "MaxRandomTemporalOffset"));	if (app.settings.haveSetting("ImagesWall", "EaseOpacity")) this.easeOpacityVal = parseInt(app.settings.getSetting("ImagesWall", "EaseOpacity"));	if (app.settings.haveSetting("ImagesWall", "PopupScale")) this.popupScaleVal = parseInt(app.settings.getSetting("ImagesWall", "PopupScale"));	if (app.settings.haveSetting("ImagesWall", "FadeZPos")) this.fadeZPosVal = parseInt(app.settings.getSetting("ImagesWall", "FadeZPos"));	if (app.settings.haveSetting("ImagesWall", "StartTime")) this.startTimeVal = parseInt(app.settings.getSetting("ImagesWall", "StartTime"));            	// Creates and displays the script interface	this.buildUI = function (thisObj)	{		// dockable panel or palette		var pal = (thisObj instanceof Panel) ? thisObj : new Window("palette", this.scriptTitle, undefined, {resizeable:true});				// resource specifications		var res =		"group { orientation:'column', alignment:['fill','fill'], alignChildren:['right','top'], \			gr1: Group { \				aboutBtn: Button { text:'" + this.aboutBtnName + "', preferredSize:[25,20] } \			}, \			gr2: Panel { text:'" + this.gridSettingsGrpName + "', alignment:['fill','fill'], alignChildren:['right','top'],\				gr21: Group { orientation:'row', \					widthSt: StaticText { text:'" + this.widthStName + "' }, \					widthEt: EditText { text:'" + this.widthVal + "', characters:8 } \				}, \				gr22: Group { orientation:'row', \					heightSt: StaticText { text:'" + this.heightStName + "' }, \					heightEt: EditText { text:'" + this.heightVal + "', characters:8 } \				}, \				gr23: Group { orientation:'row', \					durationSt: StaticText { text:'" + this.durationStName + "' }, \					durationEt: EditText { text:'" + this.durationVal + "', characters:8 } \				}, \				gr24: Group { orientation:'row', \					columnsSt: StaticText { text:'" + this.colsStName + "' }, \					colsEt: EditText { text:'" + this.colsVal + "', characters:8 } \				}, \				gr25: Group { orientation:'row', \					rowsSt: StaticText { text:'" + this.rowsStName + "' }, \					rowsEt: EditText { text:'" + this.rowsVal + "', characters:8 } \				}, \			}, \
			gr3: Panel { text:'" + this.animationSettingsGrpName + "', alignment:['fill','fill'], alignChildren:['right','top'],\				gr31: Group { orientation:'row', \					stepDurationSt: StaticText { text:'" + this.stepDurationStName + "' }, \					stepDurationEt: EditText { text:'" + this.stepDurationVal + "', characters:8 } \				}, \				gr32: Group { orientation:'row', \					fadeDurationSt: StaticText { text:'" + this.fadeDurationStName + "' }, \					fadeDurationEt: EditText { text:'" + this.fadeDurationVal + "', characters:8 } \				}, \				gr33: Group { orientation:'row', \					poolSizeSt: StaticText { text:'" + this.poolSizeStName + "' }, \					poolSizeEt: EditText { text:'" + this.poolSizeVal + "', characters:8 } \				}, \				gr34: Group { orientation:'row', \					maxRandomTemporalOffsetSt: StaticText { text:'" + this.maxRandomTemporalOffsetStName + "' }, \					maxRandomTemporalOffsetEt: EditText { text:'" + this.maxRandomTemporalOffsetVal + "', characters:8 } \				}, \				gr35: Group { orientation:'row', \					easeOpacitySt: StaticText { text:'" + this.easeOpacityStName + "' }, \					easeOpacityCb: Checkbox { text:'" + this.easeOpacityCbName + "', value:" + this.easeOpacityVal + " } \				}, \				gr36: Group { orientation:'row', \					popupScaleSt: StaticText { text:'" + this.popupScaleStName + "' }, \					popupScaleCb: Checkbox { text:'" + this.popupScaleCbName + "', value:" + this.popupScaleVal + " } \				}, \				gr37: Group { orientation:'row', \					fadeZPosSt: StaticText { text:'" + this.fadeZPosStName + "' }, \					fadeZPosCb: Checkbox { text:'" + this.fadeZPosCbName + "', value:" + this.fadeZPosVal + " } \				}, \				gr38: Group { orientation:'row', \					startTimeSt: StaticText { text:'" + this.startTimeStName + "' }, \					startTimeEt: EditText { text:'" + this.startTimeVal + "', characters:8 } \				}, \			}, \
			gr4: Group { orientation:'row', alignment:['fill','center'], alignChildren:['right','center'], \				pgsBr: Progressbar { alignment:['fill','center'], preferredSize:[-1,5] }, \				pgsSt: StaticText { text:'" + this.progressInfosStName + "', preferredSize:[140,-1] } \			}, \			gr5: Group { orientation:'row', alignment:['fill','top'], \				runBtn: Button { text:'" + this.runBtnName + "', alignment:['fill','center'] } \			} \		}"; 		pal.gr = pal.add(res);						// event callbacks		pal.onResizing = pal.onResize = function () 		{			this.layout.resize();		};						pal.gr.gr1.aboutBtn.onClick = function () 		{ 			alert(imagesWall.scriptAbout + "\r\rUsage:\r" + imagesWall.scriptUsage, imagesWall.scriptTitle);		};				pal.gr.gr2.gr21.widthEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,30000,imagesWall.widthVal,false);			imagesWall.widthVal = parseInt(this.text);		};		pal.gr.gr2.gr22.heightEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,30000,imagesWall.heightVal,false);			imagesWall.heightVal = parseInt(this.text);		};				pal.gr.gr2.gr23.durationEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,10000,imagesWall.durationVal,false);			imagesWall.durationVal = parseInt(this.text);		};		pal.gr.gr2.gr24.colsEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,1000,imagesWall.colsVal,false);			imagesWall.colsVal = parseInt(this.text);		};				pal.gr.gr2.gr25.rowsEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,1000,imagesWall.rowsVal,false);			imagesWall.rowsVal = parseInt(this.text);		};						pal.gr.gr3.gr31.stepDurationEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,1000,imagesWall.stepDurationVal,false);			imagesWall.stepDurationVal = parseInt(this.text);		};		pal.gr.gr3.gr32.fadeDurationEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,1000,imagesWall.fadeDurationVal,false);			imagesWall.fadeDurationVal = parseInt(this.text);		};				pal.gr.gr3.gr33.poolSizeEt.onChange = function () 		{ 			utils.validateNumericEdit(this,1,1000,imagesWall.poolSizeVal,false);			imagesWall.poolSizeVal = parseInt(this.text);		};						pal.gr.gr3.gr34.maxRandomTemporalOffsetEt.onChange = function () 		{ 			utils.validateNumericEdit(this,0,1000,imagesWall.maxRandomTemporalOffsetVal,false);			imagesWall.maxRandomTemporalOffsetVal = parseInt(this.text);		};						pal.gr.gr3.gr35.easeOpacityCb.onClick = function () 		{ 			imagesWall.easeOpacityVal = this.value;		};				pal.gr.gr3.gr36.popupScaleCb.onClick = function () 		{ 			imagesWall.popupScaleVal = this.value;		};						pal.gr.gr3.gr37.fadeZPosCb.onClick = function () 		{ 			imagesWall.fadeZPosVal = this.value;		};				pal.gr.gr3.gr38.startTimeEt.onChange = function () 		{ 			utils.validateNumericEdit(this,0,1000,imagesWall.startTimeVal,false);			imagesWall.startTimeVal = parseInt(this.text);		};				pal.gr.gr5.runBtn .onClick = function () 		{ 			imagesWall.create(pal);		};						// show user interface		if (pal instanceof Window)		{			pal.center();			pal.show();		}		else		{			pal.layout.layout(true);		}	   	};	// Determines whether the selected item is a folder	this.isFolderItemSelected = function () 	{		var res = false;		if (app.project.selection[0] instanceof FolderItem)		{			res = true;		}				return res;	};   		// Creates a grid from contents of selected folder item	// Return array of grid layers	this.createGrid = function (folderItem, masterFolder, pgsBr, pgsSt)	{		var err = false;		var gridComp;		//var gridLayers = [];		var cellPrecomps = [];				if (folderItem.numItems < 1)		{			err = true;		}		else		{			try			{				var proj = app.project;								gridComp = proj.items.addComp("Wall Comp - " + folderItem.name, this.widthVal, this.heightVal, 1/*comp.pixelAspect*/, this.durationVal * FRAME_DURATION, FRAME_RATE); 						gridComp.bgColor = [1,1,1];				gridComp.parentFolder = masterFolder;				var precompsFolder = proj.items.addFolder("Cell Precomps - "+ folderItem.name);				precompsFolder.parentFolder = masterFolder;				pgsBr.value = 0;				pgsBr.maxvalue = this.rowsVal * this.colsVal;				// (1) create precomps and construct grid				var realCellW = this.widthVal / this.colsVal;				var realCellH = this.heightVal / this.rowsVal;				var cellW = Math.round(realCellW);				var cellH = Math.round(realCellH);				var cellCounter = 0;				var itemCounter = 0;				clearOutput();				for (var y = 0; y < this.rowsVal; y++)				{					for (var x = 0; x < this.colsVal; x++)					{						// select an item						//var itemIdx = 1 + (itemCounter % footagesFolder.numItems);						var itemIdx = 1 + Math.floor(Math.random() * folderItem.numItems);						var footageItem = folderItem.item(itemIdx);							var cellCompLayer;						if (footageItem.width != cellW || footageItem.height != cellH)						{							// create cell precomp							var cellComp = proj.items.addComp("Cell " + (cellCounter+1), cellW, cellH, gridComp.pixelAspect, gridComp.duration, gridComp.frameRate);							cellComp.parentFolder = precompsFolder;							cellPrecomps.push(cellComp);							// add footage							var footageLayer = cellComp.layers.add(footageItem);							utils.scaleToFit(footageLayer, cellW, cellH, true);							// add cell comp to grid comp							cellCompLayer = gridComp.layers.add(cellComp);												}						else						{							cellPrecomps.push(footageItem);														// add item to grid comp							cellCompLayer = gridComp.layers.add(footageItem);						}						cellCompLayer.moveToEnd();						// position it on the grid						var xpos = (x + 0.5) * realCellW;						var ypos = (y + 0.5) * realCellH;						cellCompLayer.position.setValue([xpos,ypos]);									// adjust non-uniform scale to fit (in case of non-integral cell dimensions)						utils.scaleToFit(cellCompLayer, realCellW, realCellH, false);									// store it						//gridLayers.push(cellCompLayer);						cellCounter++;									itemCounter++;						pgsBr.value++;						var msg = "Row " + (y+1) + "/" + this.rowsVal + "  Col " + (x+1) + "/" + this.colsVal;  						pgsSt.text = msg;						writeLn(msg);							}				}							// remove precomps folder if no precomps were created				if (precompsFolder.numItems < 1)				{					precompsFolder.remove();				}			}			catch(e)			{				alert(e);				err = true;			}						}		return [err,gridComp,/* gridLayers,*/ cellPrecomps];			};		// Functional part of the script	this.create = function (pal)	{		try		{			var err = this.noFolderErr;			if (!this.isFolderItemSelected()) throw(err);		   			   	// ui params		   	var numCells = this.rowsVal * this.colsVal;		   	var totalDur = this.durationVal * FRAME_DURATION;		   	var stepDur = this.stepDurationVal * FRAME_DURATION;		   	var fadeDur = this.fadeDurationVal * FRAME_DURATION;		   	var numRandomCells = this.poolSizeVal;		   	var maxRandomTemporalOffset = this.maxRandomTemporalOffsetVal * FRAME_DURATION;		   	var easeOpacity = this.easeOpacityVal;		   	var popupScale = this.popupScaleVal;		   	var fadeZPos = this.fadeZPosVal;		   	var startTime = this.startTimeVal * FRAME_DURATION;						var pgsBr = pal.gr.gr4.pgsBr;			var pgsSt = pal.gr.gr4.pgsSt;		   			   	//pgsBr.value = 0;			//pgsBr.maxValue = numCells + (totalDur/stepDur)*numRandomCells; // grid construction + opacity animation		   				app.beginUndoGroup(this.scriptTitle);									// (0) setup			var proj = app.project;			var footagesFolder = proj.selection[0];						var masterFolder = proj.items.addFolder(footagesFolder.name + " - " + "ImagesWall "  			// store parameters in folder name for reference										+ this.widthVal + " " 										+ this.heightVal + " "										+ this.durationVal + " "										+ this.colsVal + " "										+ this.rowsVal + " "										+ this.stepDurationVal + " "										+ this.fadeDurationVal + " "										+ this.poolSizeVal + " "										+ this.maxRandomTemporalOffsetVal + " "										+ this.easeOpacityVal + " "										+ this.popupScaleVal + " "										+ this.startTimeVal);					   							// (1) construct grid			var dataFromGrid = this.createGrid(footagesFolder, masterFolder, pgsBr, pgsSt);			var gridComp = dataFromGrid[1];			//var gridLayers = dataFromGrid[2];			var cellPrecomps = dataFromGrid[2];						// (2) create fade in/out animation at random cells			var fadeOutOpacityKeyValues = [100,0];			var fadeInOpacityKeyValues = [0,100];			//var fadeOutScaleKeyValues = [[100,100],[97,97],[105,105],[90,90],[150,150],[0,0]];			//var fadeInScaleKeyValues = [[0,0],[150,150],[90,90],[105,105],[97,97],[100,100]];			var fadeOutScaleKeyValues = [[100,100],[0,0]];			var fadeInScaleKeyValues = [[0,0],[100,100]];						var fadeOutZPositionKeyValues = [0,100];			var fadeInZPositionKeyValues = [100,0];				var fadeOutOpacityKeyTimes;			var fadeInOpacityKeyTimes;			var fadeOutScaleKeyTimes;			var fadeInScaleKeyTimes;			var fadeOutPositionKeyTimes;			var fadeInPositionKeyTimes;			var easeNone = new KeyframeEase(0,0.1);			var easeIn = new KeyframeEase(0,33.3);			var easeOut = new KeyframeEase(0,33.3);						pgsBr.value = 0;			pgsBr.maxvalue = Math.round(totalDur);							for (var t = 0; t < totalDur - 0.01; t += stepDur)			{				// pick random cell indices, and new ones for replacement items 				var randomCellIndices = []; // indices start at 0				while (randomCellIndices.length < numRandomCells)				{					var idx = Math.floor(numCells * Math.random());					if (!utils.isInArray(randomCellIndices, idx))					{						randomCellIndices.push(idx);					}				}				var newRandomCellIndices = []; // indices start at 0				while (newRandomCellIndices.length < numRandomCells)				{					var idx = Math.floor(numCells * Math.random());					if (!utils.isInArray(newRandomCellIndices, idx) && randomCellIndices[newRandomCellIndices.length] != idx/*!utils.isInArray(randomCellIndices, idx)*/)					{						newRandomCellIndices.push(idx);					}				}								// for each selected cell, do fade in/out with a new image				for (var i = 0; i < numRandomCells; i++)				{					var t0 = startTime + utils.getNearestFrameTime(gridComp, t + maxRandomTemporalOffset * (Math.random() - 0.5));					var t1 = utils.getNearestFrameTime(gridComp, t0 + fadeDur);					var t2 = utils.getNearestFrameTime(gridComp, t1 + fadeDur);					fadeOutOpacityKeyTimes = [t0, t1];					fadeInOpacityKeyTimes = [t1, t2];					var fadeOutLayer = gridComp.layer(1 + randomCellIndices[i]);					fadeOutLayer.opacity.setValuesAtTimes(fadeOutOpacityKeyTimes, fadeOutOpacityKeyValues);					fadeOutLayer.outPoint = t1;										var fadeInItem;					if (cellPrecomps.length > 0)					{						fadeInItem = cellPrecomps[newRandomCellIndices[i]];					}					else					{						fadeInItem = footagesFolder.item(1 + newRandomCellIndices[i]);					}										var fadeInLayer = gridComp.layers.add(fadeInItem);																	fadeInLayer.moveBefore(fadeOutLayer);					fadeInLayer.startTime = t1;					fadeInLayer.position.setValue(fadeOutLayer.position.value);					fadeInLayer.scale.setValue(fadeOutLayer.scale.value);					fadeInLayer.opacity.setValuesAtTimes(fadeInOpacityKeyTimes, fadeInOpacityKeyValues);					if (easeOpacity)					{						for (var k = 1; k <= fadeInLayer.opacity.numKeys; k++) 						{							fadeOutLayer.opacity.setTemporalEaseAtKey(k,[easeIn],[easeOut]);							fadeInLayer.opacity.setTemporalEaseAtKey(k,[easeIn],[easeOut]);						}					}										if (popupScale)					{						//fadeInScaleKeyValues[fadeInScaleKeyValues.length-1][0] *= fadeInLayer.scale.valueAtTime(0,true)[0] / 100;						//fadeInScaleKeyValues[fadeInScaleKeyValues.length-1][1] *= fadeInLayer.scale.valueAtTime(0,true)[1] / 100;												/*						var tk1 = utils.getNearestFrameTime(gridComp, t1 - (18*FRAME_DURATION));						var tk2 = utils.getNearestFrameTime(gridComp, tk1 + (5*FRAME_DURATION));						var tk3 = utils.getNearestFrameTime(gridComp, tk2 + (3*FRAME_DURATION));						var tk4 = utils.getNearestFrameTime(gridComp, tk3 + (4*FRAME_DURATION));						var tk5 = utils.getNearestFrameTime(gridComp, tk4 + (3*FRAME_DURATION));												var tt2 = utils.getNearestFrameTime(gridComp, t1 + (5*FRAME_DURATION));						var tt3 = utils.getNearestFrameTime(gridComp, tt2 + (3*FRAME_DURATION));						var tt4 = utils.getNearestFrameTime(gridComp, tt3 + (4*FRAME_DURATION));						var tt5 = utils.getNearestFrameTime(gridComp, tt4 + (3*FRAME_DURATION));						var tt6 = utils.getNearestFrameTime(gridComp, tt5 + (3*FRAME_DURATION));												fadeOutScaleKeyTimes = [tk1, tk2, tk3, tk4, tk5, t1];						fadeInScaleKeyTimes = [t1, tt2, tt3, tt4, tt5, tt6];						*/						fadeOutScaleKeyTimes = [t0, t1]; // at opacity keytimes						fadeInScaleKeyTimes = [t1, t2];												fadeOutLayer.scale.setValuesAtTimes(fadeOutScaleKeyTimes, fadeOutScaleKeyValues);						fadeInLayer.scale.setValuesAtTimes(fadeInScaleKeyTimes, fadeInScaleKeyValues);												for (var k = 1; k <= fadeInLayer.scale.numKeys; k++) 						{							if (k == 1)							{								fadeOutLayer.scale.setTemporalEaseAtKey(k,[easeNone,easeNone,easeNone],[easeOut,easeOut,easeOut]);								fadeInLayer.scale.setTemporalEaseAtKey(k,[easeNone,easeNone,easeNone],[easeOut,easeOut,easeOut]);							}							else if (k == fadeInLayer.scale.numKeys)							{								fadeOutLayer.scale.setTemporalEaseAtKey(k,[easeIn,easeIn,easeIn],[easeNone,easeNone,easeNone]);								fadeInLayer.scale.setTemporalEaseAtKey(k,[easeIn,easeIn,easeIn],[easeNone,easeNone,easeNone]);							}							else							{								fadeOutLayer.scale.setTemporalEaseAtKey(k,[easeIn,easeIn,easeIn],[easeOut,easeOut,easeOut]);								fadeInLayer.scale.setTemporalEaseAtKey(k,[easeIn,easeIn,easeIn],[easeOut,easeOut,easeOut]);							}						}					}										if (fadeZPos)					{						fadeOutPositionKeyTimes = [t0, t1]; // at opacity keytimes						fadeInPositionKeyTimes = [t1, t2];												if (!fadeOutLayer.threeDLayer) fadeOutLayer.threeDLayer = true;						if (!fadeInLayer.threeDLayer) fadeInLayer.threeDLayer = true;												var curOutP = fadeOutLayer.position.valueAtTime(fadeOutLayer.inPoint+fadeDur,true);						var outStartPos = curOutP + [0,0,fadeOutZPositionKeyValues[0]];						var outEndPos = curOutP + [0,0,fadeOutZPositionKeyValues[1]];						var fadeOutPositionKeyValues = [outStartPos, outEndPos];						var curInP = fadeInLayer.position.valueAtTime(fadeInLayer.inPoint+fadeDur,true)						var inStartPos = curInP + [0,0,fadeInZPositionKeyValues[0]];						var inEndPos = curInP + [0,0,fadeInZPositionKeyValues[1]];						var fadeInPositionKeyValues = [inStartPos, inEndPos];												fadeOutLayer.position.setValuesAtTimes(fadeOutPositionKeyTimes, fadeOutPositionKeyValues);						fadeInLayer.position.setValuesAtTimes(fadeInPositionKeyTimes, fadeInPositionKeyValues);												for (var k = 1; k <= fadeInLayer.position.numKeys; k++) 						{							if (k == 1)							{								fadeOutLayer.position.setTemporalEaseAtKey(k,[easeNone],[easeOut]);								fadeInLayer.position.setTemporalEaseAtKey(k,[easeNone],[easeOut]);							}							else if (k == fadeInLayer.position.numKeys)							{								fadeOutLayer.position.setTemporalEaseAtKey(k,[easeIn],[easeNone]);								fadeInLayer.position.setTemporalEaseAtKey(k,[easeIn],[easeNone]);							}							else							{								fadeOutLayer.position.setTemporalEaseAtKey(k,[easeIn],[easeOut]);								fadeInLayer.position.setTemporalEaseAtKey(k,[easeInn],[easeOut]);							}						}											}										fadeOutLayer.moveToEnd(); // don't mess with layer stack since we make use of layer indices									}								pgsBr.value++; 				var msg = pgsSt.text = "Time " + (t+stepDur).toFixed(2) + "/" + totalDur.toFixed(2);				pgsSt.text = msg;				writeLn(msg);			}						pgsBr.value = 0;			pgsSt.text = this.progressInfosStName;						app.endUndoGroup();			}		catch(err) 		{			//alert(e.toString());			utils.throwErr(err);		}				// save prefs		app.settings.saveSetting("ImagesWall", "Width", this.widthVal);				app.settings.saveSetting("ImagesWall", "Height", this.heightVal); 		app.settings.saveSetting("ImagesWall", "Duration", this.durationVal);		app.settings.saveSetting("ImagesWall", "Cols", this.colsVal);		app.settings.saveSetting("ImagesWall", "Rows", this.rowsVal);		app.settings.saveSetting("ImagesWall", "StepDuration", this.stepDurationVal);		app.settings.saveSetting("ImagesWall", "FadeDuration", this.fadeDurationVal);		app.settings.saveSetting("ImagesWall", "PoolSize", this.poolSizeVal);		app.settings.saveSetting("ImagesWall", "MaxRandomTemporalOffset", this.maxRandomTemporalOffsetVal);		app.settings.saveSetting("ImagesWall", "EaseOpacity", this.easeOpacityVal);		app.settings.saveSetting("ImagesWall", "PopupScale", this.popupScaleVal);		app.settings.saveSetting("ImagesWall", "FadeZPos", this.fadeZPosVal);		app.settings.saveSetting("ImagesWall", "StartTime", this.startTimeVal); 	};		// Runs the script  	this.run = function (thisObj) 	{		this.buildUI(thisObj);	};}// This class provides some utility functionsfunction ImagesWallUtils(){	// Variable used to keep track of 'this' reference	var utils = this;		// Displays a window containg a localized error message	this.throwErr = function (err)	{		var wndTitle = $.fileName.substring($.fileName.lastIndexOf("/")+1, $.fileName.lastIndexOf("."));		Window.alert("Script error:\r" + err, wndTitle, true);	};				// Ensures input text is valid	this.validateNumericEdit = function (editControl,minVal,maxVal,dfltVal,allowFloat)	{		var inData = editControl.text;						if (isNaN(inData))		{			editControl.text = dfltVal;		}		else		{			inData = allowFloat ? parseFloat(inData) : parseInt(inData);						if (inData < minVal)			{				editControl.text = minVal;			}			else if (inData > maxVal)			{				editControl.text = maxVal;			}		}				};		// Determines whether an element is contained in the array	this.isInArray = function (array, element)	{		var found = false;		for (var i = 0; !found && i < array.length; i++)		{			if (array[i] == element) found = true;		}		return found;    	};		// Set scale value so that the layer fits the comp	this.scaleToFit = function (layer, targetW, targetH, keepRatio)	{		var layerW = layer.width;		var layerH = layer.height;		var sx = targetW / layerW;		var sy = targetH / layerH;		if (keepRatio)		{			var s = Math.max(sx,sy);			sx = s;			sy = s;		}		layer.scale.setValue(100 * [sx,sy]);	};		// Finds the time of the nearest frame	this.getNearestFrameTime = function (comp, time)	{		return comp.frameDuration * Math.round(time / comp.frameDuration);		};}// Creates an instance of the main class and run itnew ImagesWall().run(this);